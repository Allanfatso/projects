
--- This function will send new staging data to the production table

-- It will use pg_agent for scheduling near-real time data 


CREATE OR REPLACE FUNCTION process_staging_batch()
RETURNS VOID AS $$
BEGIN

    -- Locks the table to prevent modifications but allows inserts
    LOCK TABLE staging_consumption_data IN ROW EXCLUSIVE MODE;

    -- First, backs up the data by inserting into the processed staging table
    INSERT INTO consumption_data_staging_processed (LCL_ID, STD_OR_TOU, Date_Time, KWHperHR)
    SELECT lcl_id, std_or_tou, date_time, kwhperhr
    FROM staging_consumption_data
    ON CONFLICT (LCL_ID, Date_Time) DO NOTHING;
    -- Then, inserts into the main fact table
    INSERT INTO Consumption_data (LCL_ID, STD_OR_TOU, Date_Time, KWHperHR, Tariff_ID)
    SELECT 
        s.lcl_id, 
        s.std_or_tou, 
        s.date_time, 
        s.kwhperhr, 
        t.Tariff_ID
    FROM staging_consumption_data s
    LEFT JOIN Tariffs t ON s.date_time = t.Date_Time
    ON CONFLICT (LCL_ID, Date_Time) DO NOTHING;

    -- Finally, deletes the transferred rows from staging
    DELETE FROM staging_consumption_data
	WHERE (LCL_ID, Date_Time) IN (
    SELECT LCL_ID, Date_Time FROM consumption_data_staging_processed
	);

END;
$$ LANGUAGE plpgsql;


-- pgagent job

-- will call the function. Instead of call, select will be used as call is
-- for procedures

select process_staging_batch();


--- the pgagent job would therefore look like this:

DO $$
DECLARE
    jid integer;
    scid integer;
BEGIN
-- Creating a new job
INSERT INTO pgagent.pga_job(
    jobjclid, jobname, jobdesc, jobhostagent, jobenabled
) VALUES (
    2::integer, 'get_new_data'::text, 'This job is responsible for transferring data from staging environment to production environment for the consumption_data table.'::text, 'Allan'::text, true
) RETURNING jobid INTO jid;

-- Steps
-- Inserting a step (jobid: NULL)
INSERT INTO pgagent.pga_jobstep (
    jstjobid, jstname, jstenabled, jstkind,
    jstconnstr, jstdbname, jstonerror,
    jstcode, jstdesc
) VALUES (
    jid, 'transfer'::text, true, 's'::character(1),
    ''::text, 'postgres'::name, 'f'::character(1),
    'select process_staging_batch();'::text, 'Transfer the data to consumption_data.'::text
) ;

-- Schedules
-- Inserting a schedule (generated by pgAdmin)

INSERT INTO pgagent.pga_schedule(
    jscjobid, jscname, jscdesc, jscenabled,
    jscstart, jscend, jscminutes, jschours, jscweekdays, jscmonthdays, jscmonths
) VALUES (
    jid, 'time_schedule'::text, ''::text, true,
    '2025-03-10 00:00:00 +00:00'::timestamp with time zone, '2025-07-31 00:00:00 +01:00'::timestamp with time zone,
    -- Minutes: Runs at minute 5
    '{f,f,f,f,f,t,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}'::bool[]::boolean[],
    -- Hours: Runs every hour (all set to true)
    '{t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t}'::bool[]::boolean[],
    -- Week days: Runs every day of the week (all set to true)
    '{t,t,t,t,t,t,t}'::bool[]::boolean[],
    -- Month days: Runs on all days of the month (all set to true)
    '{t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t,t}'::bool[]::boolean[],
    -- Months: Runs every month (all set to true)
    '{t,t,t,t,t,t,t,t,t,t,t,t}'::bool[]::boolean[]
) RETURNING jscid INTO scid;





--- The following was added after testing was completed



-- Trigger function adds a tar
CREATE OR REPLACE FUNCTION staging_enrich_tariff()
RETURNS TRIGGER AS $$
BEGIN
  NEW.tariff_id := (
    SELECT t.tariff_id
    FROM tariffs t
    WHERE t.date_time = NEW.date_time
    LIMIT 1
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger
CREATE TRIGGER trg_enrich_tariff
  BEFORE INSERT ON staging_consumption_data
  FOR EACH ROW
  EXECUTE FUNCTION staging_enrich_tariff();
